<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SameGame</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="output1" style="position:absolute; top:10px; left:10px; width:100px; background-color:#FFFFE0;border:1px solid #804000; padding:10px">SameGame3D</div>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": { "three": "https://unpkg.com/three/build/three.module.js" }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

        var mouseIsDown = false; // diese Zeile wird gebraucht, warum auch immer
        var countCubes = 9 * 9 * 9;
        var x, y, z;
        var countPoints = 0;
        var countDeletedBalls = 0;

        // scene
        const scene = new THREE.Scene();

        // camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6.5;

        // renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // light
        const light = new THREE.AmbientLight(0xffffff, 0.5);
        light.castShadow = true;
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 32, 64)
        scene.add(directionalLight);

        // orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);

        // function to add shapes
        const addNewMesh = (x, y, z) => {
            const colorindex = Math.floor(Math.random() * 3);
            const sphereGeometry = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            var sphereMaterial;
            if (colorindex == 0)
                sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, });
            else if (colorindex == 1)
                sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, });
            else
                sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereMesh.position.set(x, y, z);
            scene.add(sphereMesh);
        };

        for (x = -4; x <= 4; x++) {
            for (y = -4; y <= 4; y++) {
                for (z = -4; z <= 4; z++) {
                    addNewMesh(x / 2, y / 2, z / 2);
                }
            }
        }

        function DeleteBalls(x, y, z, color) {
            scene.traverse(function (node) {
                if (node instanceof THREE.Mesh) {
                    if (node.position.x == x && node.position.y == y && node.position.z == z && node.material.color.getHex() == color) {
                        node.position.x = 9999;
                        countCubes--;
                        countDeletedBalls++;
                        DeleteBalls(x + 0.5, y, z, color);
                        DeleteBalls(x - 0.5, y, z, color);
                        DeleteBalls(x, y + 0.5, z, color);
                        DeleteBalls(x, y - 0.5, z, color);
                        DeleteBalls(x, y, z + 0.5, color);
                        DeleteBalls(x, y, z - 0.5, color);
                    }
                }
            });
        }

        function BallExistsAt(xx, yy, zz) {
            var ballFound = false;
            scene.traverse(function (ball) {
                if (ball instanceof THREE.Mesh) {
                    if (ball.position.x == xx && ball.position.y == yy && ball.position.z == zz) ballFound = true;
                }
            });
            return ballFound;
        }

        function LowerBalls() {
            var somethingChanged = true;
            while (somethingChanged) {
                somethingChanged = false;
                scene.traverse(function (node) {
                    if (node instanceof THREE.Mesh) {
                        if (node.position.x != 9999 && node.position.y > -2 && !BallExistsAt(node.position.x, node.position.y - 0.5, node.position.z)) {
                            somethingChanged = true;
                            node.position.y -= 0.5;
                        }
                    }
                });
            }
            somethingChanged = true;
            while (somethingChanged) {
                somethingChanged = false;
                scene.traverse(function (node) {
                    if (node instanceof THREE.Mesh) {
                        if (node.position.x != 9999 && node.position.x > -2 && !BallExistsAt(node.position.x - 0.5, node.position.y, node.position.z)) {
                            somethingChanged = true;
                            node.position.x -= 0.5;
                        }
                    }
                });
            }
            somethingChanged = true;
            while (somethingChanged) {
                somethingChanged = false;
                scene.traverse(function (node) {
                    if (node instanceof THREE.Mesh) {
                        if (node.position.x != 9999 && node.position.z > -2 && !BallExistsAt(node.position.x, node.position.y, node.position.z - 0.5)) {
                            somethingChanged = true;
                            node.position.z -= 0.5;
                        }
                    }
                });
            }
        }

        // raycaster
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerMove(event) {
            if (mouseIsDown) {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length > 0) {
                    countDeletedBalls = 0;
                    var color = intersects[0].object.material.color.getHex();
                    DeleteBalls(intersects[0].object.position.x, intersects[0].object.position.y, intersects[0].object.position.z, color);
                    LowerBalls();
                    if (countDeletedBalls > 2)
                        countPoints += (countDeletedBalls - 1) * (countDeletedBalls - 1);
                    else
                        countPoints += countDeletedBalls;
                    if (countCubes == 0) {
                        var highScores = [];
                        var highScoreAsString, highScoreAsInteger;
                        highScoreAsString = localStorage.getItem('HighScore0');
                        if (highScoreAsString == "") highScoreAsString = "0";
                        highScoreAsInteger = Number(highScoreAsString);
                        highScores.push(highScoreAsInteger);
                        highScoreAsString = localStorage.getItem('HighScore1');
                        if (highScoreAsString == "") highScoreAsString = "0";
                        highScoreAsInteger = Number(highScoreAsString);
                        highScores.push(highScoreAsInteger);
                        highScoreAsString = localStorage.getItem('HighScore2');
                        if (highScoreAsString == "") highScoreAsString = "0";
                        highScoreAsInteger = Number(highScoreAsString);
                        highScores.push(highScoreAsInteger);
                        highScores.push(countPoints);
                        highScores.sort(function(a, b){return a - b});
                        localStorage.setItem('HighScore0', highScores[1].toString());
                        localStorage.setItem('HighScore1', highScores[2].toString());
                        localStorage.setItem('HighScore2', highScores[3].toString());
                        document.getElementById('output1').innerHTML = "Game over : " + countPoints.toString() + " Punkte<br>---<br>" + highScores[1].toString() + "<br>" + highScores[2].toString() + "<br>" + highScores[3].toString();
                    }
                    else
                        document.getElementById('output1').innerHTML = countPoints.toString() + " Punkte";
                }
            }
        }

        var mouseDown = function (e) {
            mouseIsDown = true; // diese Zeile wird gebraucht, warum auch immer
            onPointerMove(e);
        }

        window.addEventListener('mousedown', mouseDown, false);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>
</html>